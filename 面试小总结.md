# 面试题小结



### 简述const、var、let 定义变量的区别之处

```
1.const定义的变量不可以修改，而且必须初始化。

 const a = 1;
 a = 2;
 console.log(a) //报错
	
2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。

3.let是块级作用域，函数内部使用let定义后，对函数外部无影响,如果不初始化会输出undefined，不会报错。
	function a() {
		let c = 6;
		console.log(c) //6
	}
	a()

	let c = 3;
	console.log(c) //3
```

### 简述原型链的工作原理

```
ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。
其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
在JavaScript中，用 __proto__ 属性来表示一个对象的原型链。
当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止！

```

### let al = [ , , , ]与let a2 = Array(3)一样吗，为什么

```
不一样的
let al = [,,,]数组是[undefined * 3] //数组的有三个元素，三个元素的值为undefined
a2 = Array(3)该数组只有长度，打印为[undefined * 3]，是数组的元素没有初始化，默认为undefined


let a = [1, 2, 3, 4, 5];
 a.length = 3;  
 console.log(a)//[1, 2, 3]; 长度为3

a.length = 0;
console.log(a.length); //[]； 长度为0
	
a.length = 5;
console.log(a.length);// [undefined * 5]; 长度为5
```



### javascript的函数调用有几种方法，其中call()和apply在调用函数时有那些不同

```
1. 函数名()
	
2. 匿名函数的自调用 (function() {})(window)
	
3. fn.bind()();//返回了一个绑定this对象相同的方法上。上面的代码修改一行就可以实现绑定this在a对象上目的。

	var a = function () {
		var a = 1;
		console.log(this); //function () {var b = 2;}
	}

	a.c = function () {
		var b = 2;
	}
	a.bind(a.c)(); //改变了a函数的this指向


4. fn.call()
5. func.apply()
他们都支持多参数，而且第一个参数都是即将绑定的this对象，
第二个参数则是他们的区别所在，call使用独立的参数作为调用方法的入参，
apply使用一个数组作为入参。有的时候我们并不是不想改变this对象，
而是想人为的将他绑定到别的对象上，这个时候call和apply是很好用的（并不是说不能用bind，不过貌似bind出现的比较晚，可能浏览器兼容性不好）
	
var a = function () {
	var a = 1
	console.log(this); //function () {}
}
a.c = function () {}
	a.call(a.c); //改变了a函数的this指向
	a.apply(a.c) //改变了a函数的this指向
```



### 关于ES6的几个小案例

```
Object.assign小解:
	var a = {x: 1}
	var b = {y: 2}
	var c = Object.assign(a, b) //除了第一个对象,后面所有的对象都不变
	console.log(c) //{x: 1, y: 2}
	console.log(a) //{x: 1, y: 2}
	console.log(b) //{y: 2} 


1.写出下面程序的执行结果
	let a = [1, 2, 3, 4];
	let b = a.map((x, i) => { //遍历数组a，x为元素，i为下标
		//return x += i;
		return x = x + i;
	});
	console.log(`a:${a}`); //a:1,2,3,4
	console.log(`b:${b}`); //b:1,3,5,7
	console.log('a:' + a); //a:1,2,3,4
	console.log('b:' + b); //b:1,3,5,7
	
2.写出下面程序的执行结果
	let o = {};
	let p = Object.assign(o, {});//现在的o是一个空对象，并把这个对象赋给了p，o === p(true)
	let q = Object.assign({}, o); //新创建的一个空对象，并且赋给了q，o和q是两个不同的引用，所以不等
	console.log(`o == p: ${o == p}`); //true
	console.log(`o == q: ${o == q}`); //false
```



### 小案例

```
写出下面代码打印结果:
	(function () {
		var x = y = 5; //先把5赋给了没有用var声明的变量y，然后再把y的值赋给了通过var声明的变量x
	})();

	console.log(y); //5 (没有var，全局变量)
	console.log(x + "_" + y); //报错 x is not defined  (通过var声明，在函数里是局部变量)
```

